<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>NEMS: Running: NEMSCompsetRun</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="make-images-fit.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NEMS
   &#160;<span id="projectnumber">feature/documentation@6b989eaee9</span>
   </div>
   <div id="projectbrief">This is a living document and may be updated at any time.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('running.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Running: NEMSCompsetRun </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>NEMS uses "component sets", or "`compsets`," to systematically label run configurations. The labels are associated with scripts that pull together all the files and inputs needed to run the specified configurations. Compset labels include which components and mediators are part of the configuration, whether each component is running in a prognostic or test mode, resolutions, and initial conditions. This approach offers a number of benefits:</p>
<ul>
<li>standard runs can be set up easily and consistently</li>
<li>it is a very effective way to implement regression testing across a coupled system with many possible combinations of components</li>
<li>easy access to configurations with non-prognostic versions of components facilitates controlled experimentation</li>
</ul>
<p>Compsets were originated by the <a href="http://www.cesm.ucar.edu/models/cesm1.2/cesm/doc/modelnl/compsets.html">Community Earth System Model (CESM)</a>.</p>
<p><a href="https://docs.google.com/spreadsheets/d/1v9tJb03YuCbwDsXff4M5i6jz4lvBxUrhdImqaGnK_IE/edit#gid=0">Supported NEMS compsets are listed here</a>.</p>
<h2>Old and New NEMSCompsetRun </h2>
<p>The NEMS is transitioning from an old compset runner to a new one. The old system was based on model-specific workflows that duplicated one another's fuctionality. The new one is a more generic tool which uses an abstract description to generate the workflow. Both systems are explained in this document - older repository revisions referred to by the milestones still require use of the older NEMSCompsetRun.</p>
<p>In both systems, the compset front-end is at: </p>
<pre class="fragment">./NEMS/NEMSCompsetRun [arguments]
</pre><p>Executing this front-end will start one or more compsets, potentially in parallel, and eventually report the results. What varies between the old and new systems is the calling convention, capabilities and internals.</p>
<h3>Comparison of compset runners</h3>
<table class="doxtable">
<tr>
<th>Capability </th><th>Old runner </th><th>New runner  </th></tr>
<tr>
<td>Editable shell scripts </td><td>yes </td><td>no </td></tr>
<tr>
<td>Connection to build system </td><td>no </td><td>yes </td></tr>
<tr>
<td>Parallel execution of compsets </td><td>no </td><td>yes </td></tr>
<tr>
<td>Re-running failed compset </td><td>no </td><td>yes </td></tr>
</table>
<h2>New NEMSCompsetRun </h2>
<p>This system generates workflow scripts from an abstract description of compsets. Users can specify multiple compsets either by name or by grouping. The system allows basic set arithmetic operations to combine several group of compsets into a single workflow. Any dependencies are automatically resolved, including compilation of NEMS executables. The generated workflow is run by the Rocoto workflow manager. That manager allows failed compsets or builds to be rerun manually, or automatically.</p>
<h2>Design and Capabilities </h2>
<p>This system works on a different principle than the older one. The old system ran shell scripts specific to each model or test which copied files from outside the NEMS test area and ran external programs to generate some inputs.</p>
<p>The new system has a directory of prepared inputs, has no external dependencies, and simply runs the NEMS executable without any test-specific scripts. In other words, scripts like the <code>exglobal_fcst_nems.sh</code> are no longer used. This makes porting and workflow changes simpler, but has the disadvantage of not testing model workflow scripts. That disadvantage is intentional; the purpose of the NEMS regression tests is to test the NEMS, not model workflow scripts.</p>
<h2>Running the System </h2>
<p>This section explains how to run the system in its simplest form. Later sections discuss how to check the status of the execution, rerun a failed job, or resume a workflow (such as after logging out).</p>
<h3>Initial Execution</h3>
<p>The first step is to start the workflow: </p>
<pre class="fragment">./NEMS/NEMSCompsetRun [options] [run-mode] compset-specification
</pre><p>Options will be discussed later. The <code>run-mode</code> determines whether the system will create a new baseline, or execute and verify against the old baseline. To generate a new baseline: </p>
<pre class="fragment">./NEMS/NEMSCompsetRun [options] --baseline compset-specification
</pre><p>Without that <code>--baseline</code> flag, the system will run in the default mode: execute the tests and verify against the baseline.</p>
<p>The compset specification can be done in the following ways. These select either specific compsets or groups of compsets. We will discuss how compset groups work, in the next section.</p>
<ul>
<li><code>--baseline</code> &ndash; run all tests that are part of the baseline</li>
<li><code>-f</code> &ndash; run all known tests</li>
<li><code>-s</code> &ndash; run tests in the "standard" group</li>
<li><code>--compset (compset-name)</code> &ndash; run the specified compset</li>
<li><code>group-name</code> &ndash; run the specified group of compsets</li>
<li><code>set-specification</code> &ndash; set arithmetic that specifies the compsets to run. This is discussed in detail in the next section.</li>
</ul>
<h3>Compset Groups</h3>
<p>The NEMSCompsetRun can group together several compsets, to allow users to run multiple compsets without having to type each one. Compset groups are defined in the <code>compsets/all.input</code>. As of this writing, the <code>all.input</code> for the NEMSGSM app was the following: </p>
<pre class="fragment">load 'gsm.input'

run gfs_eulerian           @ gfs, standard, baseline
run wam_gh_l150            @ gfs, standard, baseline, wam
run wam_gh_l150_nemsio     @ gfs, standard, baseline, wam
run gfs_slg                @ gfs, standard, baseline, slg
run gfs_slg_2thread        @ gfs, standard, baseline, slg, plat==wcoss.phase1
run gfs_slg_48pe           @ gfs, standard, baseline, slg
run gfs_slg_adiabatic      @ gfs, standard, baseline, slg
run gfs_slg_land           @ gfs, standard, baseline, slg
run gfs_slg_nsst           @ gfs, standard, baseline, slg
run gfs_slg_rsthst         @ gfs, standard, baseline, slg
run gfs_slg_stochy         @ gfs, standard, baseline, slg
run gfs_slg_t574           @ gfs, standard, baseline, slg
run gfs_gocart_nemsio      @ gfs, standard, baseline, gocart
</pre><p>The <code>run</code> lines list known compsets and which groups they belong to. In later sections, we will discuss the <code>load 'gsm.input'</code> and how compsets are defined. The text between <code>run</code> and <code>@</code> is a compset name, while after the <code>@</code> lists the groups to which the compset belongs. Let's examine these three: </p>
<pre class="fragment">run gfs_eulerian           @ gfs, standard, baseline
run wam_gh_l150            @ gfs, standard, baseline, wam
run wam_gh_l150_nemsio     @ gfs, standard, baseline, wam
</pre><p>All three are part of the <code>gfs</code> group, as well as the <code>standard</code> and <code>baseline</code> groups. Only the <code>wam_gh_l150</code> and <code>wam_gh_l150_nemsio</code> are part of the <code>wam</code> group. Hence, if we ask to run the <code>wam</code> group of compsets, the <code>gfs_eulerian</code> will not be run. If we ask to run the <code>gfs</code> group, all three will be run.</p>
<p>There are two special compset groups:</p>
<ul>
<li><code>standard</code> &ndash; all compsets run by <code>NEMSCompsetRun -s</code></li>
<li><code>baseline</code> &ndash; all compsets run when a baseline is generated.</li>
</ul>
<p>The <code>baseline</code> set allows a special usage: some compsets are intended to generate the same results as one another. This is often used for regression testing, such as ensuring that different decompositions of a grid generate the same results. In such situations, you only want to run one control when generating baselines.</p>
<h3>Compset Groups and Set Arithmetic</h3>
<p>The NEMSCompsetRun understands basic set arithmetic operations. For example, this requests execution of all <code>gocart</code> and <code>wam</code> compsets: </p>
<pre class="fragment">./NEMS/NEMSCompsetRun 'union(gocart,wam)'
</pre><p>You can also specify lists of compsets: </p>
<pre class="fragment">./NEMS/NEMSCompsetRun '{gfs_slg_t574,gfs_slg}'
</pre><p>and use such compsets in set arithmetic. For example, if we want to run all GFS semilagrangian tests except <code>gfs_slg</code> and <code>gfs_slg_t574</code>: </p>
<pre class="fragment">./NEMS/NEMSCompsetRun 'minus(slg,{gfs_slg_t574,gfs_slg})'
</pre><p>The set arithmetic understands the following:</p>
<ul>
<li><code>union(group1,group2)</code> &mdash; union of group1 and group2</li>
<li><code>inter(group1,group2)</code> &mdash; intersection of group1 and group2</li>
<li><code>minus(group1,group2)</code> &mdash; all compsets in group1 that are not in group2</li>
<li><code>*</code> &mdash; the universal set (all known compsets)</li>
<li><code>{compset1,compset2,compset3}</code> &mdash; compsets compset1, compset2, and compset3</li>
</ul>
<p>In all cases, explicit compset sets (<code>{compset1,compset2,compset3}</code>) can be used in place of groups. Also, nested operations are allowed: </p>
<pre class="fragment">./NEMS/NEMSCompsetRun minus(*,union(minus(slg,{gfs_slg_t574,gfs_slg}),gocart))
</pre><h3>Options: Disk Area, Batch System Account, and More</h3>
<p>The NEMSCompsetRun has a number of command-line options for configuring various aspects of execution. There is one special option: </p>
<pre class="fragment">./NEMS/NEMSCompsetRun --help
</pre><p>which will print a usage message, describing options and compset specification syntax.</p>
<h4>Resources</h4>
<p>The following will be given suitable defaults, if possible, on your platform. In some cases, no default is possible. For example, Jet has no system-wide temporary area so the user must specify that manually.</p>
<ul>
<li><code>--project=project</code> &mdash; specifies the CPU project or account under which jobs will be submitted.</li>
<li><code>--temp-dir=/path/to/temp/area</code> &mdash; scrub area in which to generate the workflow and execute the compsets. The NEMSCompsetRun will make a subdirectory, <code>rtgen.(number)</code>, underneath this directory.</li>
</ul>
<h4>Generation and Execution</h4>
<ul>
<li><code>--baseline-dir</code> &mdash; the location of the baseline. In baseline generation mode, this is the directory in which to place the baseline. In execution mode, this is the area that contains the baseline against which to compare runs. The default is specified in the compset platform description, discussed in detail in a later section.</li>
<li><code>--dry-run</code> &mdash; don't run anything. Just print what would be done.</li>
<li><code>--verbose</code> &mdash; be verbose</li>
<li><code>--mode=MODE</code> &mdash; run in <code>BASELINE</code> mode or verify against a baseline in <code>EXECUTION</code> mode</li>
<li><code>--baseline</code> &mdash; generate a baseline; same as <code>--mode=BASELINE</code></li>
<li><code>--resume</code> &mdash; continue execution of a terminated workflow. This is discussed in detail in the next section.</li>
</ul>
<h3>Resuming and Rerunning</h3>
<p>The NEMSCompsetRun supports rerunning failed jobs and resuming a terminated workflow. If a user logs out or kills (control-C) the NEMSCompsetRun process, it can be resumed with the <code>--resume</code> option. If a compset or build job has failed, the user can rerun the failed job via the <code>rtrewind</code> command, and then use the <code>NEMSCompsetRun --resume</code> to resume the workflow. The <code>rtreport</code> command reports on the status of the build and compset jobs.</p>
<p>All of these commands require the path to the generated workflow. That path is printed out by NEMSCompsetRun: </p>
<pre class="fragment">/home/you&gt;  ./NEMS/NEMSCompsetRun [options] compset-specificaton
... other log messages ...
Test will run in: /path/to/temp-dir/rtgen.NUMBER
</pre><h4>Resuming the Workflow</h4>
<p>After the NEMSCompsetRun is terminated, you can resume the workflow by starting a new NEMSCompsetRun for the same directory: </p>
<pre class="fragment">./NEMS/NEMSCompsetRun --resume /path/to/temp-dir/rtgen.NUMBER
</pre><p>Note that it is critical never to run two NEMSCompsetRun processes for the same workflow at the same time. Although it will usually work, there is a chance that a batch job or Rocoto will fail when its script is being rewritten.</p>
<h4>Getting the Status of a Workflow</h4>
<p>The <code>rtreport</code> program displays a short or long status message. The long format is the default. It prints the status of all compsets and builds, and detailed verification information: </p>
<pre class="fragment">/path/to/temp-dir/rtgen.NUMBER/rtreport
</pre><p>The short message just reports the number of jobs completed or failed, and explicitly lists failed jobs: </p>
<pre class="fragment">/path/to/temp-dir/rtgen.NUMBER/rtreport status
</pre><h4>Rerunning Failed Jobs</h4>
<p>The first step to rerunning failed jobs is to figure out which jobs have failed: </p>
<pre class="fragment">/path/to/temp-dir/rtgen.NUMBER/rtreport status
</pre><p>This will print lines like the following: </p>
<pre class="fragment">build_gsm-ww3.exe: FAIL: /path/to/temp-dir/rtgen.NUMBER/tmp/log/build_gsm-ww3.log
</pre><p>The <code>build_gsm-ww3.exe</code> is the name of the failed job. The <code>rtrewind</code> command will tell the NEMSCompsetRun's "Rocoto" tool to forget it ran a job, so that it will rerun later: </p>
<pre class="fragment">/path/to/temp-dir/rtgen.NUMBER/rtrewind build_gsm-ww3.exe
</pre><dl class="section note"><dt>Note</dt><dd>You do NOT need to terminate NEMSCompsetRun when running <code>rtrewind</code>. Rocoto has proper file locking mechanisms to allow it to safely rewind a running workflow.</dd></dl>
<p>If you do terminate NEMSCompsetRun, then you must resume it, as discussed earlier.</p>
<h3>Interpreting the Log Messages</h3>
<p>After running the NEMSCompsetRun, you will see log messages like the following: </p>
<pre class="fragment">11/17 18:42:38Z rtgen-INFO:  Will run all known tests.
11/17 18:42:50Z rtgen-INFO:  Auto-chosen project for job submission is 'cmp'
11/17 18:42:51Z rtgen-INFO:  Auto-chosen ptmp is '/path/to/USERNAME'
11/17 18:42:51Z rtgen-INFO:  Generating workflow with id 23768.
11/17 18:42:55Z rtgen-INFO:  Requested test has been generated.
11/17 18:42:55Z rtgen-INFO:  Test will run in: /path/to/USERNAME/rtgen.23768
</pre><p>These messages include timestamps, and a warning level. In this case, nothing went wrong, so the level is <code>INFO</code>. These first few messages contain critical information:</p>
<ul>
<li><code>Will run all known tests</code> &mdash; describes the tests to be run. If you use options like <code>-s</code> or <code>union(wam,gocart)</code> then this will be stated.</li>
<li><code>... project for job submission is 'cmp'</code> &mdash; the accounting project used for submission to the batch queue. This can be manually specified with the <code>--project</code> option.</li>
<li>`... ptmp is '/path/to/USERNAME'<code>--- scrub area. This can be manually specified with the</code>&ndash;temp-dir` option.</li>
<li><code>Test will run in: /path/...</code> &mdash; location in which the test is generated.</li>
</ul>
<p>During the bulk of the execution, the <code>NEMSCompsetRun</code> will generate output like this: </p>
<pre class="fragment">11/17 00:19:21Z rtrun INFO: check dependencies and submit jobs...
11/17 00:19:22Z rtrun INFO: check status...
11/17 00:19:22Z rtrun INFO: workflow is still running and no jobs have failed.
11/17 00:19:22Z rtrun INFO: sleep 2
11/17 00:19:24Z rtrun INFO: get queue information
573626        dev          64 R  11/17 00:14 /.../tmp/log/test_gfs_gocart_nemsio.log
</pre><p>It will keep looping until all jobs have succeeded or failed. If all goes well, the tests will all pass and you will see this message: </p>
<pre class="fragment">11/17 00:21:04Z rtrun INFO: check dependencies and submit jobs...
11/17 00:21:05Z rtrun INFO: check status...
11/17 00:21:05Z rtrun INFO: workflow is complete and all jobs succeeded.
</pre><h2>Work Area Contents </h2>
<p>Running the <code>rtgen</code> creates a directory in a scrub area which will contain the generated scripting system, input and output files, logs, and resource usage information. This section documents those files and directories.</p>
<p>Recall that running <code>rtgen</code> creates a directory with a name like this: </p>
<pre class="fragment">/path/to/USERNAME/rtgen.23768
</pre><p>That directory contains the following:</p>
<ul>
<li>rtrun script</li>
<li>rtreport script</li>
<li>jobs directory</li>
<li>scripts directory</li>
<li>ush directory</li>
<li>src directory</li>
<li>install.sh</li>
<li>uninstall.sh</li>
<li>exec directory</li>
<li>include directory</li>
<li>rocoto directory</li>
<li>com directory</li>
<li>tmp directory</li>
<li>tmp/log directory</li>
</ul>
<h3>Jobs, Scripts and Ush</h3>
<p>These are the three tier NCEP workflow directories and have the usual meanings:</p>
<ul>
<li>jobs - sets up the environment and passes control to the "scripts" level</li>
<li>scripts - high-level logic for each compset</li>
<li>ush - low-level utility functions</li>
</ul>
<p>For each compset, there is one "jobs" directory file and one "scripts" directory file. The "scripts" directory and "jobs" directory are populated by the compset blocks which will be discussed in great detail in the <a class="el" href="running.html#desc_lang">Compset Description Language</a> section. They are generated from the [compset blocks](new-compsets).</p>
<h3>Src, Exec, and Include</h3>
<p>The <code>src</code> directory does not contain source code. Instead, it contains two scripts that describe how to build or uninstall the <code>NEMS.x</code></p>
<ul>
<li>install.sh - knows how to build the NEMS.x based on the instructions in the [build blocks](new-build) as explained in the [Compset Description Language](desc_lang) section in great detail.</li>
<li>uninstall.sh - deletes the copies of <code>NEMS.x</code> and <code>modules.nems</code> created by install.sh.</li>
</ul>
<p>The <code>install.sh</code> creates executables and modulefiles which are copied into the <code>exec</code> and <code>include</code> directories.</p>
<ul>
<li>exec - one executable for each NEMS build</li>
<li>include - one file for each NEMS build containing a sequence of of "module load" commands. These commands will be run before executing the NEMS.x</li>
</ul>
<h3>Rocoto Directory</h3>
<p>The <code>rtgen</code> makes one file in the <code>rocoto</code> directory. The <code>rtrun</code> will create a second file.</p>
<ul>
<li>workflow.xml - the definition of the workflow generated by <code>rtgen</code>. This includes dependencies and resource requirements. There is one shell command for each compset or build.</li>
<li>workflow.db - created by <code>rtrun</code>, this contains the Rocoto internal state information.</li>
</ul>
<h3>Tmp and Logs</h3>
<p>The <code>tmp</code> directory contains all logs and all execution directories for each compset.</p>
<ul>
<li><code>tmp/log/rocoto.log</code> - log file from Rocoto. Contains information about batch system events, such as job failures or job submissions.</li>
<li><code>tmp/log/*.log</code> - all other files contain logs about a compset or build</li>
<li><code>tmp/*</code> - all other directories are work areas for compsets. They contain inputs and outputs from the NEMS.x</li>
</ul>
<h3>Scripts rtrun and rtreport</h3>
<p>These are discussed in earlier sections. The scripts are generated automatically by <code>rtgen</code>. The <code>rtrun</code> runs Rocoto and the <code>rtreport</code> scans the reports, combining them into one text file.</p>
<h3>COM directory</h3>
<p>This directory contains one subdirectory for each compset with all verified files as described in a compset's <a class="el" href="running.html#criteria">criteria</a> block. It also contains the "report.txt" file with the report of the compset success or failure.</p>
<p><a class="anchor" id="desc_lang"></a></p>
<h2>5.4 Compset Description Language </h2>
<p>This chapter discusses the language used by the <code>rtgen</code> tool to describe regression tests and compsets. The language consists of "modules" which are simply a collection of variables and functions. A module has a type: build, compset, hash, etc. A set of <code>run</code> commands list which runnable modules should be executed.</p>
<h3>Variable Definitions and Modules</h3>
<p>The simplest type of module is a hash, which looks like this: </p>
<pre class="fragment">nems_vars={
atm_model='none'
atm_petlist_bounds="-1 -1"
ocn_model='none'
ocn_petlist_bounds="-1 -1"
ice_model='none'
ice_petlist_bounds="-1 -1"
med_model='nems'
med_petlist_bounds="-1 -1"
med_atm_coupling_interval_sec='-1'
med_ocn_coupling_interval_sec='-1'
}
</pre><p>In this example, we have declared a hash called <code>nems_vars</code> which contains several variables, such as <code>atm_model</code> and <code>atm_petlist_bounds</code>. Later on, another module declaration can "use" this module, to import its variables: </p>
<pre class="fragment">nmm_vars_global={
use plat%nmm_dflt
use nems_vars
use common_vars
use nmm_vars
use nmm_aliases
use nmm_uncoupled
GBRG="glob"
CNTL_NAME='NMMB_glob'
}
</pre><p>Values can include variable substitution, which uses a similar syntax as shell, but with different escape characters: </p>
<pre class="fragment">common_vars={
THRD=1
WLCLK=15
GEFS_ENSEMBLE=0
GEN_ENSEMBLE=0
WRITE_DOPOST='.false.'
POST_GRIBVERSION='grib1'
CONF="@[plat%PARMnems]"
}
</pre><p>Here, the <code>CONF</code> variable in the <code>common_vars</code> module has the value of the <code>PARMnems</code> variable in the <code>plat</code> module.</p>
<h3>Strings</h3>
<p>There are three ways of specifying a string:</p>
<ul>
<li>Double quotes: "... text here with @[VARIABLE] expansion ..."</li>
<li>Single quotes: '... text here with no variable expansion ...'</li>
<li><p class="startli">Block string:</p>
<p class="startli">[[[multi-line string with @[VARIABLE] expansion ]]]</p>
</li>
</ul>
<p>If you need to insert a literal @ into the string, you have three options. In these examples, we'll use the multi-line string format:</p>
<ul>
<li>`[[[ @['this text is not expanded'] ]]]<code> *</code>[[[ @["this text is not expanded"] ]]]<code> *</code>[[[ Simple literal @[@] ]]]`</li>
</ul>
<h3>Embedded Scripts</h3>
<p>Most of the scripts required to run the compsets are automatically generated, but there are occasional instances when you need to specify specific code. This is done via <code>embed</code> blocks: </p>
<pre class="fragment">embed bash nems_compset_prep(RUNDIR,modules,CNTL) [[[
mkdir -p "$RUNDIR" "$CNTL"
cd @[RUNDIR]
source "$modules"
export MPI_TYPE_DEPTH=20
export ESMF_RUNTIME_COMPLIANCECHECK=OFF:depth=4
]]]
</pre><p>In this example, we have embedded a bash script called <code>nems_compset_prep</code>.</p>
<h4>Embedded Script Variables: <code>$</code> vs. <code>@</code></h4>
<p>In the example script, there are two methods of doing variable substitution:</p>
<ul>
<li><code>@[RUNDIR]</code></li>
<li><code>"$RUNDIR"</code></li>
</ul>
<p>They have slightly different meanings. In the case of <code>@[RUNDIR]</code>, the value of the <code>RUNDIR</code> variable is substituted directly in the generated script. If the variable contained any shell metacharacters, those would be copied verbatim. In the case of <code>$RUNDIR</code>, the bash variable is used instead. That variable's value is set before the code in <code>nems_compset_prep</code> is run.</p>
<p>Either approach is valid. It is up to the user to decide which one to use.</p>
<h3>Platform Detection</h3>
<p>The compset suite needs to reconfigure certain aspects based on platform; WCOSS vs. Theia vs. GAEA, etc. This is done with <code>platform</code> blocks. These are simply modules with a <code>detect</code> function. After all platforms are defined, an <code>autodetect</code> block selects between them.</p>
<p>Here is an example of a platform. This is the one for Phase 1 of WCOSS. </p>
<pre class="fragment">platform wcoss.phase1 {
    use wcoss.common
    CPU_ACCOUNT='NAM-T2O'
    pex='1'
    cores_per_node=32
    MPI='LSF'
    SHORT_TEST_QUEUE='&amp;SHORTQ;'
    LONG_TEST_QUEUE='&amp;LONGQ;'
    BUILD_QUEUE='&amp;BUILDQ;'

    embed bash detect [[[
        # This function is used at PARSE TIME to detect whether we are
        # on WCOSS Phase 1.  It must be very fast and low resource
        # usage since the parser runs it.
        if [[ -d /usrx &amp;&amp; -d /global &amp;&amp; -e /etc/redhat-release &amp;&amp; \\
            -e /etc/prod ]] ; then
            # We are on WCOSS Phase 1 or 2.
            if ( ! cat /proc/cpuinfo |grep 'processor.*32' ) ; then
                # Fewer than 32 fake (hyperthreading) cpus, so Phase 1.
                exit 0
            fi
        fi
        exit 1
    ]]]
    ... more wcoss stuff ...
}
</pre><p>Note the <code>embed bash</code> block called <code>detect</code>. This is the bash function that is run to detect whether the script is running on WCOSS Phase 1.</p>
<p>Once all platforms are defined, there is an autodetect block: </p>
<pre class="fragment">autodetect plat (/ wcoss.phase1, theia /)
</pre><p>This will define the <code>plat</code> variable, which is a duplicate of either <code>wcoss.phase1</code> or <code>theia</code>.</p>
<h3>Build Definition</h3>
<p>The <code>build</code> blocks define a method of building an executable. They must define three variables and a function:</p>
<ul>
<li><code>NEMS.x</code> = path to the NEMS executable created by this build</li>
<li><code>modules.nems</code> = list of "module load" commands to execute before running the executable</li>
<li><code>target</code> = file to check to ensure the build succeeded; should be the same as the <code>NEMS.x</code> variable</li>
<li><code>build</code> = an <code>embed bash</code> function that builds the program.</li>
</ul>
<p>Here is an example. This builds the GOCART-capable standalone GSM in the NEMSLegacy branch: </p>
<pre class="fragment">build gsm_gocart.x {
    use plat
    NEMS.x="@[plat%EXECrt]/NEMS_gocart.x"
    modules.nems="@[plat%INCrt]/NEMS_gocart.x.modules"
    target="@[NEMS.x]"
    build=NEMSAppBuilder(NEMS.x="@[NEMS.x]",modules.nems="@[modules.nems]",
    OPTS="app=GSM-GOCART")
}
</pre><p>The NEMSAppBuilder function is declared elsewhere. It is used by most of the <code>build</code> definitions to avoid duplication. That function looks like this: </p>
<pre class="fragment">embed bash NEMSAppBuilder(NEMS.x,modules.nems,OPTS)
[[[
    mkdir -p "@[plat%EXECrt]" "@[plat%INCrt]"
    rm -f "@[NEMS.x]" "@[modules.nems]"
    cd @[plat%HOMEnems]

    # NOTE: Replace "rebuild" with "norebuild" to disable "gmake clean"
    ./NEMS/NEMSAppBuilder rebuild $OPTS

    cd @[plat%SRCnems]
    cp -fp ../exe/NEMS.x "@[NEMS.x]"
    cp -fp conf/modules.nems "@[modules.nems]"
]]]
</pre><p>Notice that the four variables we're passing from <code>gsm_gocart.xbuild</code> are in the definition line of NEMSAppBuilder: </p>
<pre class="fragment">embed bash NEMSAppBuilder(NEMS.x,modules.nems,OPTS)
...
build gsm_gocart.x {
...
build=NEMSAppBuilder(NEMS.x="@[NEMS.x]",modules.nems="@[modules.nems]",
OPTS="app=GSM-GOCART")
</pre><h3>Compsets</h3>
<p>A compset block is a module that defines the following:</p>
<ul>
<li>dependencies - any other compsets or builds that have to run first</li>
<li><code>prep</code> - a preparation step to run before anything else. This is generally <code>mkdir</code>, <code>module</code> or <code>cd</code> commands.</li>
<li><code>input</code> - a <code>filter</code> block that provides a list of input files or directories and instructions on how to copy or filter them. This is described below.</li>
<li><code>execute</code> - a <code>spawn</code> block that describes how to run the <code>NEMS.x</code>. This is also used to generate job cards to request the needed resources.</li>
<li><code>output</code> - criteria for validating the compset output. These are usually <code>criteria</code> blocks, described below.</li>
</ul>
<p>This is the <code>compset</code> block for the global nmm control. Later text describe the meaning of each part: </p>
<pre class="fragment"># nmm_cntrl compset
compset nmm_cntrl: nmm.x {
    use nmm_vars_global

    # Convenience variables:
    RUNDIR_ROOT="@[plat%TMPrt]"
    RUNDIR="@[RUNDIR_ROOT]/@[TEST_NAME]"
    TEST_DESCR="Compare NMMB-global results with previous trunk version"
    CNTL="@[plat%BASELINE]/@[CNTL_NAME]"      # Control baseline area
    TEST_IN="@[plat%INPUTS]/@[CNTL_NAME]"   # Compset-specific input data
    COM="@[plat%COMrt]/@[TEST_NAME]"

    criteria output {
        #    NEMS.x output file --------- comparison - control file or dir
        "nmmb_hst_01_bin_0000h_00m_00.00s" .bitcmp. "@[CNTL]"
        "nmmb_hst_01_bin_0024h_00m_00.00s" .bitcmp. "@[CNTL]"
        "nmmb_hst_01_bin_0048h_00m_00.00s" .bitcmp. "@[CNTL]"
        "nmmb_hst_01_nio_0000h_00m_00.00s" .bitcmp. "@[CNTL]"
        "nmmb_hst_01_nio_0024h_00m_00.00s" .bitcmp. "@[CNTL]"
        "nmmb_hst_01_nio_0048h_00m_00.00s" .bitcmp. "@[CNTL]"
        "nmmb_rst_01_bin_0024h_00m_00.00s" .bitcmp. "@[CNTL]"
        "nmmb_rst_01_nio_0024h_00m_00.00s" .bitcmp. "@[CNTL]"
    }

    # The prep is run at the top of any job.  It should do such things
    # like making directories and loading modules.
    prep=nems_compset_prep(
    RUNDIR="@[RUNDIR]",modules="@[nmm.x%modules.nems]",
    CNTL="@[CNTL]")

    # The execute step runs the program:
    spawn execute {
        { "@[nmm.x%NEMS.x]", ranks="@[TASKS]", threads="@[OpenMPThreads]" }
    }

    filters input {
        # work file         operation   input file
        "input_domain_01"        &lt;=copy= "@[TEST_IN]/test_input_nmmb_global"
        "input_domain_01_nemsio" &lt;=copy= "@[TEST_IN]/test_input_nmmb_global.nemsio"
        "GWD_bin_01"             &lt;=copy= "@[TEST_IN]/GWD_bin_01"

        "nems.configure"      &lt;=atparse= "@[CONF]/nems.configure.@[nems_configure].IN"
        "atmos.configure"     &lt;=atparse= "@[CONF]/atmos.configure_nmm"

        "configure_file_01"   &lt;=atparse= "@[CONF]/nmm_conf/nmm_@[GBRG]_conf.IN"
        "model_configure"        &lt;=copy= "configure_file_01"

        "*"                   &lt;=copydir= "@[plat%NMM_DATA]"

        "VEGPARM.TBL"            &lt;=copy= "IGBP_VEGPARM.TBL"
        "LANDUSE.TBL"            &lt;=copy= "IGBP_LANDUSE.TBL"
        "ETAMPNEW_DATA"          &lt;=copy= "ETAMPNEW_DATA.expanded_rain"
        "fort.28"                &lt;=link= "global_o3prdlos.f77"
        "fort.48"                &lt;=link= "global_o3clim.txt"

        "solver_state.txt"       &lt;=copy= "@[plat%PARMnems]/solver_state.txt"
        "nests.txt"              &lt;=copy= "@[plat%PARMnems]/nests.txt"
    }
}
</pre><h4>Compset Dependencies</h4>
<p>The first line (after the comment) is this: </p>
<pre class="fragment">compset nmm_cntrl: nmm.x {
</pre><p>The <code>: nmm.x</code> indicates that the <code>nmm.x</code> build has to run before the <code>nmm_cntrl</code> can start. The test suite will include that dependency in its Rocoto automation system.</p>
<h4>Compset Prep</h4>
<p>The prep step is a simple script that prepares the environment. In this case, it just runs the nems_compset_prep, which we discussed earlier: </p>
<pre class="fragment"># The prep is run at the top of any job.  It should do such things
# like making directories and loading modules.
prep=nems_compset_prep(
    RUNDIR="@[RUNDIR]",modules="@[nmm.x%modules.nems]",
    CNTL="@[CNTL]")
</pre><p>Note that it refers to <code>@[RUNDIR]</code> and <code>@[CNTL]</code>. Those variables are defined earlier in the same compset: </p>
<pre class="fragment"># Convenience variables:
RUNDIR_ROOT="@[plat%TMPrt]"
RUNDIR="@[RUNDIR_ROOT]/@[TEST_NAME]"
TEST_DESCR="Compare NMMB-global results with previous trunk version"
CNTL="@[plat%BASELINE]/@[CNTL_NAME]"      # Control baseline area
TEST_IN="@[plat%INPUTS]/@[CNTL_NAME]"   # Test-specific input data
COM="@[plat%COMrt]/@[TEST_NAME]"
</pre><h4>Compset Input Filter</h4>
<p>This block specifies the input files and how to prepare them. It declares an <code>input</code> variable inside the <code>nmm_cntrl</code> compset, which is of type <code>filters</code>: </p>
<pre class="fragment">filters input {
    # work file           operation  input file
    "input_domain_01"        &lt;=copy= "@[TEST_IN]/test_input_nmmb_global"
    "input_domain_01_nemsio" &lt;=copy= "@[TEST_IN]/test_input_nmmb_global.nemsio"
    "GWD_bin_01"             &lt;=copy= "@[TEST_IN]/GWD_bin_01"

    "nems.configure"      &lt;=atparse= "@[CONF]/nems.configure.@[nems_configure].IN"
    "atmos.configure"     &lt;=atparse= "@[CONF]/atmos.configure_nmm"

    "configure_file_01"   &lt;=atparse= "@[CONF]/nmm_conf/nmm_@[GBRG]_conf.IN"
    "model_configure"        &lt;=copy= "configure_file_01"

    "*"                   &lt;=copydir= "@[plat%NMM_DATA]"

    "VEGPARM.TBL"            &lt;=copy= "IGBP_VEGPARM.TBL"
    "LANDUSE.TBL"            &lt;=copy= "IGBP_LANDUSE.TBL"
    "ETAMPNEW_DATA"          &lt;=copy= "ETAMPNEW_DATA.expanded_rain"
    "fort.28"                &lt;=link= "global_o3prdlos.f77"
    "fort.48"                &lt;=link= "global_o3clim.txt"

    "solver_state.txt"       &lt;=copy= "@[plat%PARMnems]/solver_state.txt"
    "nests.txt"              &lt;=copy= "@[plat%PARMnems]/nests.txt"
}
</pre><p>Notice that there are four different operations in the middle column:</p>
<table class="doxtable">
<tr>
<th>Local file </th><th>Operation </th><th>Remote file or directory  </th></tr>
<tr>
<td><code>"GWD_bin_01"</code> </td><td><code>&lt;=copy=</code> </td><td><code>"\@[TEST_IN]/GWD_bin_01"</code> </td></tr>
<tr>
<td><code>"*"</code> </td><td><code>&lt;=copydir=</code> </td><td><code>"\@[plat%NMM_DATA]"</code> </td></tr>
<tr>
<td><code>"fort.28"</code> </td><td><code>&lt;=link=</code> </td><td><code>"global_o3prdlos.f77"</code> </td></tr>
<tr>
<td><code>"atmos.configure"</code> </td><td><code>&lt;=atparse=</code> </td><td><code>"\@[CONF]/atmos.configure_nmm"</code> </td></tr>
</table>
<ul>
<li><code>&lt;=copy=</code> - copies the remote file (third column) to the local file (first column). <pre class="fragment">cp -p "$third_column" "$first_column"
</pre></li>
<li><code>&lt;=link=</code> - makes a symbolic link to the remote file (third column) from the local file (first column) <pre class="fragment">ln -s "$third_column" "$first_column"
</pre></li>
<li><code>&lt;=copydir=</code> - copies from the remote file or directory (third column) all files that match the glob (first column) into the local directory. <pre class="fragment">cp -rp "$third_column"/$first_column
</pre></li>
<li><code>&lt;=atparse=</code> - runs the remote file (third column) through a filter to create the local file (first column). The filter will replace text like <code>@[varname]</code> with the corresponding variable.</li>
</ul>
<p>In the <code>&lt;=atparse=</code> variable replacement, only variables from the compset's module are replaced. Hence, if you want many variables accessible to <code>&lt;=atparse=</code>d files, you need to either declare or <code>use</code> them. The <code>nmm_cntrl</code> compset does that at the top of its declaration: </p>
<pre class="fragment">compset nmm_cntrl: nmm.x {
use nmm_vars_global

# Convenience variables:
RUNDIR_ROOT="@[plat%TMPrt]"
RUNDIR="@[RUNDIR_ROOT]/@[TEST_NAME]"
TEST_DESCR="Compare NMMB-global results with previous trunk version"
CNTL="@[plat%BASELINE]/@[CNTL_NAME]"      # Control baseline area
TEST_IN="@[plat%INPUTS]/@[CNTL_NAME]"   # Compset-specific input data
COM="@[plat%COMrt]/@[TEST_NAME]"
</pre><p>Everything in the <code>nmm_vars_global</code> module will be available plus all six of the declared "convenience variables"</p>
<p>Note that variables with a period (".") or percent ("%") in their name are not yet available. That will be fixed in a later release.</p>
<h4>Compset Execution</h4>
<p>The next step is to actually run the <code>NEMS.x</code>: </p>
<pre class="fragment"># The execute step runs the program:
spawn execute {
{ "@[nmm.x%NEMS.x]", ranks="@[TASKS]", threads="@[OpenMPThreads]" }
}
</pre><p>The columns inside the <code>execute</code> block have these meanings:</p>
<ul>
<li><code>"\@[nmm.x%NEMS.x]"</code> - the program to run</li>
<li><code>ranks="\@[TASKS]"</code> - number of mpi ranks</li>
<li><code>threads="\@[OpenMPThreads]"</code> - optional; number of threads per rank. Default is 1.</li>
<li>ppn=8 - not used here; optional. Specifies the number of MPI ranks per node. The GSM needs this due to memory limits. Default is calculated automatically by the system, and will be the largest number of MPI ranks possible.</li>
</ul>
<p><a class="anchor" id="criteria"></a></p>
<h4>Compset Verification or Baseline Generation</h4>
<p>The last step is to either verify the results or generate the baseline. Both cases are handled by the output criteria block: </p>
<pre class="fragment">criteria output {
#    NEMS.x output file --------- comparison - control file or dir
"nmmb_hst_01_bin_0000h_00m_00.00s" .bitcmp. "@[CNTL]"
"nmmb_hst_01_bin_0024h_00m_00.00s" .bitcmp. "@[CNTL]"
"nmmb_hst_01_bin_0048h_00m_00.00s" .bitcmp. "@[CNTL]"
"nmmb_hst_01_nio_0000h_00m_00.00s" .bitcmp. "@[CNTL]"
"nmmb_hst_01_nio_0024h_00m_00.00s" .bitcmp. "@[CNTL]"
"nmmb_hst_01_nio_0048h_00m_00.00s" .bitcmp. "@[CNTL]"
"nmmb_rst_01_bin_0024h_00m_00.00s" .bitcmp. "@[CNTL]"
"nmmb_rst_01_nio_0024h_00m_00.00s" .bitcmp. "@[CNTL]"
}
</pre><p>The columns have this meaning:</p>
<ul>
<li><code>"nmmb_hst_01_bin_0000h_00m_00.00s"</code> - local directory file</li>
<li><code>.bitcmp.</code> - verification method. Only <code>.bitcmp.</code> is supported for now.</li>
<li><code>"\@[CNTL]"</code> - remote directory file or remote directory that contains the baseline. If it is a remote directory, the file is assumed to have the same name.</li>
</ul>
<p>In verification mode, the comparisons are performed after running NEMS.x</p>
<p>In baseline generation mode, the local file (first column) is copied to the remote location (third column).</p>
<h3>List of Available Compsets and Sets</h3>
<p>The configuration for <code>rtgen</code> is stored in the compsets/all.input file in the app level repository. This is where you specify the available compsets and sets of compsets.</p>
<p>The top few lines of that file look like this </p>
<pre class="fragment">load 'gsm.input'
load 'nmm.input'
run nmm_cntrl              @ nmm, standard, baseline, nmmglob
run nmm_nemsio             @ nmm,                     nmmglob
run nmm_rest               @ nmm,                     nmmglob
... many more "run" statements ...
</pre><p>The first two lines import the details of the compset from other files. The lines beginning with <code>run</code> specify a compset to run and the sets it belongs to. The compset must be one declared in the other file, as discussed later in this document.</p>
<p>The list of sets after the @ sign are the ones recognized by the subsetting functionality of rtgen.</p>
<p>Note that you can enable compsets on only certain platforms by including a comparison operator in the list of subsets:</p>
<p>run gfs_slg_2thread @ gfs, standard, baseline, slg, plat==wcoss.phase1</p>
<p>This line ensures the <code>gfs_slg_2thread</code> is only available on WCOSS Phase 1. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
