<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>NEMS: Compiling: NEMSAppBuilder and GNUmakefile</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="make-images-fit.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NEMS
   &#160;<span id="projectnumber">feature/documentation@6b989eaee9</span>
   </div>
   <div id="projectbrief">This is a living document and may be updated at any time.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('building.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Compiling: NEMSAppBuilder and GNUmakefile </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>NEMS is the technical backbone for multiple modeling applications. These modeling applications are multi-component coupled systems that must pull together, in a systematic way, components from different centers and agencies. The build system enables users to construct a specific, versioned modeling application from a versioned set of model components and configuration files.</p>
<p>The NEMS build system uses a GNU Makefile built on top of the GNU Make Standard Library. The prior approach, the NEMSAppBuilder, a massive shell script, has been abandoned. A script by the same name is in place, but it is simply a wrapper around "make." This was created to support existing software; it is suggested to switch to calling the GNU Makefile directly because it provides more fine-grained control over what to build and when.</p>
<p>The build system is split into two levels: Application and NEMS. In situations where both levels have a capability, the application version (if present) overrides the NEMS settings. This allows multiple applications to use the same NEMS, while having slightly different component build rules or modulefile selections.</p>
<ul>
<li>Application level:<ul>
<li>Version of NEMS.</li>
<li>List of external components and frameworks (MOM6, FV3, CICE, FMS, etc.)</li>
<li>Version of each external component or framework.</li>
<li>Location of source and installation areas for each external component or framework.</li>
<li>Build rules for each component and framework.</li>
<li>Build environment, such as compilers, MPI selection, and third-party libraries.</li>
</ul>
</li>
<li>NEMS level:<ul>
<li>Dependencies between components and frameworks (ie. FMS must be built before MOM6)</li>
<li>Location of source and installation areas for each external component or framework.</li>
<li>Build rules for each component and framework.</li>
<li>Coupling system based on ESMF/NUOPC.</li>
</ul>
</li>
</ul>
<h2>Building with the GNU Makefile </h2>
<p>The top-level makefile is located within the <a class="el" href="structure.html">Repository Structure and Versioning</a> as ./NEMS/GNUmakefile. It is a GNU makefile, and will not work with other Make implementations.</p>
<p>The first step to running the build system is to be within the NEMS directory </p>
<pre class="fragment">git clone (insert url here) my-app
cd my-app/NEMS
</pre><p>You must <code>cd</code> into the <code>NEMS/</code> directory before you execute the new build system.</p>
<p>There are two ways to call the makefile: with an appBuilder file, or without. Here is an example command line that will build the coupled FV3-MOM6-CICE5 on NOAA RDHPCS Theia with the Intel compiler: </p>
<pre class="fragment">make COMPONENTS=FV3,MOM6,CICE \
     CHOSEN_MODULE=theia.intel/fv3_coupled \
     CONFOPT=configure.fv3_coupled.theia.intel \
     build
</pre><p>An equivalent way to do this is to place the commands within an appBuilder file. The appBuilder files belong at the application level (directory above NEMS). One of the advantages of an appBuilder file is that some of the build system information is available to facilitate automatic decisions, such as machine-specific configuration. An appBuilder file for the coupled FV3-MOM6-CICE5 would look something like this: </p>
<pre class="fragment"># Contents of coupledFV3_MOM6_CICE.appBuilder
COMPONENTS=( FV3 MOM6 CICE )
CHOSEN_MODULE=$FULL_MACHINE_ID/fv3_coupled
CONFOPT=configure.fv3_coupled.$FULL_MACHINE_ID
</pre><p>Note the addition of the <code>$FULL_MACHINE_ID</code>. That is one of several special variables discussed later. Also notice that the file is a bash shell script. This was done for backward compatibility, to prevent users from having to rewrite their existing appBuilder files. However, only a limited set of variables is forwarded from the appBuilder file to Make. These are listed later in this page.</p>
<p>The new command to build would be: </p>
<pre class="fragment">make app=coupledFV3_MOM6_CICE build
</pre><p>Later sections will discuss variables to configure the build environment, variables that configure components, and different build targets for compiling or cleaning NEMS (or parts thereof).</p>
<h3>Instructing the NEMS build system: Phony Targets</h3>
<p>The NEMS build system can be instructed to do various things, such as cleaning NEMS (or part of it), building NEMS (or part of it), or providing information about the build. This is implemented via what are called "phony targets." Those are build targets that do not correspond to an actual file. An example from the above section is the "build" target: </p>
<pre class="fragment">make [options] build
</pre><p>Internally, that enables targets for the NEMS executable and all component ESMF makefile fragments.</p>
<p>There are several other build rules for the NEMS level, and several for each component:</p>
<ul>
<li><code>build</code> &mdash; compile the NEMS executable and all ESMF makefile fragments</li>
<li><code>clean</code> &mdash; delete compiler intermediate files (.o, .mod, etc.) from NEMS and all components or frameworks.</li>
<li><code>distclean</code> &mdash; in addition to <code>clean</code>, deletes final targets like libraries, the NEMS executable, and ESMF makefile fragments.</li>
<li><code>debug_info</code> &mdash; the default target if none is specified; provides information about the build environment and selected components.</li>
</ul>
<p>For each component or external framework, there are three more rules to act just on that. For a hypothetical component "FOO:"</p>
<ul>
<li><code>build_FOO</code> &mdash; create the ESMF makefile fragment for FOO, and any other targets needed to link FOO to NEMS.</li>
<li><code>clean_FOO</code> &mdash; delete all of FOO's compiler intermediate files</li>
<li><code>distclean_FOO</code> &mdash; same as <code>clean_FOO</code> but also deletes the ESMF makefile fragment, the component's library and any other non-intermediate targets.</li>
</ul>
<h3>The Build Environment</h3>
<p>There are three steps to setting up the build environment, and are described in more detail in comments within the <code>NEMS/GNUmakefile</code>:</p>
<ol type="1">
<li>Platform capability settings, controlled by the <code>BUILD_ENV</code> variable. This also sets up defaults for later steps.</li>
<li>Selection of <code>configure.nems</code>, <code>modules.nems</code>, and other configuration files. These are generally chosen by the application level, but suitable defaults are provided.</li>
<li>Application overrides of steps 1 and 2.</li>
</ol>
<p>The goal of these steps is to set values for the following variables, which configure later steps of the build:</p>
<ul>
<li><code>BUILD_ENV</code> &mdash; a description of the build environment, used to select one by name. Generally, this should be the FULL_MACHINE_ID or BUILD_TARGET.</li>
<li><code>MACHINE_ID</code> &mdash; a short name for the machine, excluding any details about the build environment or partition. Example: "wcoss" for NOAA WCOSS phases 1, 2, and 3.</li>
<li><code>FULL_MACHINE_ID</code> &mdash; a longer name for the machine, which may include more information about the build environment or partition. Example: "wcoss_phase2" for NOAA WCOSS Phase 2.</li>
<li><code>USE_MODULES</code> &mdash; <code>YES</code> or <code>NO</code>: does the unix "module" command work on this machine? If <code>NO</code>, the modules.nems will be "sourced" as a shell include file instead.</li>
<li><code>MODULE_LOGIC</code> &mdash; a shell command or series of shell commands to load the <code>modules.nems</code> file.</li>
<li><code>BUILD_TARGET</code> &mdash; the machine and partition description, and further details about the build environment. It must have the format <code>.</code> where MACHINE is the FULL_MACHINE_ID or the MACHINE_ID.</li>
<li><code>NEMS_COMPILER</code> &mdash; the name of a compiler suite to use, such as gnu, pgi, or intel.</li>
<li><code>DEFAULT_MODULE</code> &mdash; the default modulefile or shell include file to use for modules.nems on this platform.</li>
<li><code>MODULE_DIR</code> &mdash; the directory that contains application modulefiles for this platform. Default is the <code>modulefiles/</code> relative to the application level.</li>
<li><code>CHOSEN_MODULE</code> &mdash; the name of the modulefile within <code></code> to use as <code>modules.nems</code>.</li>
<li><code>MODULE_LIST</code> &mdash; optional: a shell command or sequence of shell commands to list the loaded modules.</li>
<li><code>CONFIGURE_NEMS_FILE</code> &mdash; the location of the <code>configure.nems</code> file, either an absolute path or a path relative to the application-level <code>conf/</code> directory.</li>
<li><code>ESMF_VERSION_DEFINE</code> &mdash; the location of the <code>NEMS/src/ESMFVersionDefine.h</code> file, either an absolute path or a path relative to the application-level <code>conf/</code> directory.</li>
<li><code>EXTERNALS_NEMS_FILE</code> &mdash; the location of the <code>externals.nems</code> file, either an absolute path or a path relative to the application-level <code>conf/</code> directory.</li>
</ul>
<p>The list of known build environments (values of <code>BUILD_ENV</code>) are obtained via the logic within <code>NEMS/src/incmake/env/</code> and application-level <code>conf/env</code>. Each subdirectory of <code>env</code> contains a <code>detect.mk</code> which detects the build environments available on the current machine, and specifies a makefile fragment that will set up the environment. For example, on the NOAA Jet cluster, the four detected build environments will be <code>jet</code>, <code>linux.gnu</code>, <code>linux.intel</code>, and <code>linux.pgi</code>.</p>
<h3>Parallel Builds</h3>
<p>In Make, a parallel build is requested by the <code>-j</code> option: </p>
<pre class="fragment">make -j 8 [options] build
</pre><p>Within the makefile, when another make is executed in a certain way (called a submake), the <code>-j</code> option is passed down to it. Hence, executing <code>make</code> at the top level with the <code>-j</code> option will pass that same option down to all components.</p>
<p>Note that some components will fail to build, or build incorrectly, if they receive <code>-j</code> options greater than zero. For those components, it is critical that their <code>component_FOO.mk</code> explicitly set <code>-j 1</code> in submakes to disable parallel builds of that component's internal build system.</p>
<h2>Configuring the NEMS Build </h2>
<h3>Component Build Configuration</h3>
<p>The components are specified via the <code></code> variable. That is a space-separated or comma-separated list of components that should be included in the NEMS build. Components may be added or reordered based on the logic in the <code>NEMS/src/incmake/dependencies.mk</code> file. Example: </p>
<pre class="fragment">COMPONENTS=FV3 MOM6 CICE CCPP
</pre><p>would build the coupled FV3-MOM6-CICE5 system with CCPP included. In reality, CCPP must be built first, and FMS is required as well. The <code>NEMS/src/incmake/dependencies.mk</code> knows this, and will update the components list: </p>
<pre class="fragment">COMPONENTS=FMS CCPP FV3 MOM6 CICE
</pre><p>For each component FOO, these variables may be set to control how and where it is built:</p>
<ul>
<li><code>foo_mk</code> &mdash; the path to the ESMF makefile fragment for the component</li>
<li><code>FOO_BINDIR</code> &mdash; the path to the directory that contains the component's library and any other files needed to link the component to NEMS.</li>
<li><code>FOO_SRCDIR</code> &mdash; the directory that contains the component source code</li>
<li><code>FOO_MAKEOPT</code> &mdash; component "make" options; the meaning is component-specific.</li>
<li><code>FOO_CONFOPT</code> &mdash; component configuration options; the meaning is component-specific.</li>
<li><code>FOO_BUILDOPT</code> &mdash; component build options; the meaning is component-specific.</li>
</ul>
<p>Each component's build rules, in <code>NEMS/src/incmake/component_FOO.mk</code>, decides how to build the component, based on those six variables. The NEMS build logic, in <code>NEMS/src/GNUmakefile</code>, will decide how to link the component, based on <code>FOO_BINDIR</code> and the ESMF makefile fragment.</p>
<p>As a convenience, in the <code></code> variable, a component name may be followed by a series of options of the form <code>FOOOPT1=ARG1OPT2=ARG2%...</code>. If so, the <code>OPT=ARG</code> pairs are added to the special <code>FOO_MAKEOPT</code> variable for that component. For example, if we want to build FV3 and FMS in debug mode, using the component list from before: </p>
<pre class="fragment">COMPONENTS=FV3%DEBUG=Y MOM6 CICE5 CCPP
</pre><h3>Build Environment Specification Files: <code>modulefile</code> and <code>configure</code> File</h3>
<p>The NEMS build system requires two files to set up the build environment.</p>
<ul>
<li><code>modulefiles/(machine)/(modulefile)</code> - This will become <code>NEMS/src/conf/modules.nems</code>. On a machine with the UNIX <code>module</code> command, this will be loaded as a modulefile. On other machines, this file will be "sourced" as a shell include file.</li>
<li><code>conf/configure.nems.*</code> - coped to <code>NEMS/src/conf/configure.nems</code>. This sets variables required by NEMS build scripts. This is a Makefile fragment, which will be included by the makefiles within <code>NEMS/src</code>. Some components use this file as well, such as the FV3.</li>
</ul>
<h3>Modifying Component Build Rules or Adding Components</h3>
<p>An example <code>component_FOO.mk</code> with more detailed instructions can be found in <code>NEMS/src/incmake/example_component_FOO.mk</code>. Please read that example before attempting to add or modify a component; we provide information here as well for the benefit of this document's readers. This information is not sufficient though; you must read the example file as well.</p>
<p>Adding a component FOO is as simple as adding this file: </p>
<pre class="fragment">NEMS/src/incmake/component_FOO.mk
</pre><p>OR, at the application level: </p>
<pre class="fragment">conf/component_FOO.mk
</pre><p>If both are present, the application-level file is used. If a component has dependencies, then this file must be updated: </p>
<pre class="fragment">NEMS/src/incmake/dependencies.mk
</pre><p>For technical reasons, at this time, that file cannot be overridden at the application level.</p>
<p>At a minimum, the <code>component_FOO.mk</code> must set these four variables: </p>
<pre class="fragment">foo_mk=$(FOO_BINDIR)/foo.mk
all_component_mk_files+=$(foo_mk)

FOO_SRCDIR?=$(ROOTDIR)/FOO
FOO_BINDIR?=$(ROOTDIR)/FOO_INSTALL
</pre><p>Note that the <code>FOO_SRCDIR</code> and <code>FOO_BINDIR</code> are default values which are overridden by any earlier setting. The <code>foo_mk</code> can only be overridden by the environment or command-line.</p>
<p>The <code>all_component_mk_files</code> variable tracks the ESMF makefile fragments the <code>NEMS/src/GNUmakefile</code> uses to build the NEMS-specific source code and link the NEMS executable.</p>
<p>The <code>component_FOO.mk</code> must also have these build rules: </p>
<pre class="fragment">build_FOO: $(foo_mk)

$(foo_mk): configure
    ... rules for building the FOO component ...

clean_FOO: 
    ... rules for cleaning the FOO intermediate files ...

distclean_FOO: clean_FOO
    rm -rf $(FOO_BINDIR) $(foo_mk)
    ... delete any other FOO targets ...
</pre><p>You must be aware of some of the details of how submakes work, and the interactions between makefile fragments, before attempting to add or modify a component. The <code>NEMS/src/incmake/example_component_FOO.mk</code> explains these issues in more detail.</p>
<h3>The <code>modules.nems</code></h3>
<p>Some systems have the unix <code>module</code> command. On those systems, the NEMS <code>modulefiles</code> must follow the standard <code>modulefile</code> syntax. On systems without the <code>module</code> command, the <code>modules.nems</code> file is simply a POSIX sh include file.</p>
<p>On systems with the <code>module</code> command, the <code>modules.nems</code> must be a valid modulefile. On systems without the <code>module</code> command (<code>USE_MODULES=NO</code>), the <code>modules.nems</code> is simply a POSIX sh include script.</p>
<p>Modulefiles must begin with this line: </p>
<pre class="fragment">#%Module######################################################################
</pre><p>Other lines specify the modules to load. Here is the full modulefile for one of the GFS apps on WCOSS: </p>
<pre class="fragment">#%Module######################################################################
# This script is responsible for loading modules that are compatible with
# the NUOPC Layer version used in NEMS.

module load  EnvVars/1.0.0
module load ibmpe lsf NetCDF/4.2/serial ESMF/700
module load ics/15.0.3
</pre><p>Note that this is not a shell script; it is tcl script. You cannot have any <code>source</code> or <code>export</code> commands. It is best to stick with these two commands if possible:</p>
<ul>
<li><code>module load module-name</code></li>
<li><code>module use /p/a/t/h</code></li>
</ul>
<p>The <code>modulefiles</code> can contain other commands, the most common of which are:</p>
<ul>
<li><code>prepend-path /p/a/t/h</code></li>
<li><code>append-path /p/a/t/h</code></li>
<li><code>remove-path /p/a/t/h</code></li>
<li><code>setenv variable value</code></li>
<li><code>unsetenv variable</code></li>
<li><code>set variable value</code></li>
<li><code>unset variable</code></li>
</ul>
<p>There are multiple implementations of the <code>module</code> command, some of which have more powerful features. On some platforms, you may have to use the more advanced features in order to properly set up the environment. That is why NEMS uses a different modulefile for each platform.</p>
<p>No matter what you do, you must follow this critical rule:</p>
<dl class="section warning"><dt>Warning</dt><dd>Never put a <code>module purge</code> command in a <code>modulefile</code>.</dd></dl>
<p>Placing a <code>module purge</code> in a <code>modulefile</code> will cause infinite loops, corrupted environments, or segfaults of the <code>module</code> command on some platforms. The NEMS scripts already purge the modules by running a "shell include" file before loading your <code>modulefile</code>. This script can be found in:</p>
<ul>
<li><code>NEMS/src/conf/module-setup.sh.inc</code> (for bash, sh, and ksh)</li>
<li><code>NEMS/src/conf/module-setup.csh.inc</code> (for csh and tcsh)</li>
</ul>
<h3>For More Information About <code>make</code> and <code>modulefiles</code></h3>
<p>Good general resources for learning about <code>modulefiles</code> are:</p>
<ul>
<li>NICS module website: <a href="http://www.nics.tennessee.edu/computing-resources/modules">http://www.nics.tennessee.edu/computing-resources/modules</a></li>
<li><p class="startli">The <code>module</code> command: </p>
<pre class="fragment">module help # list allowed "module" commands
module avail # list available modules
module spider # also list modules in hidden families
</pre><p class="startli">Note that the <code>module spider</code> command is only available on platforms that are able to hide modules that are unavailable without prerequisites. For example, hiding a <code>NetCDF</code> library that was compiled with <code>gfortran</code> until the <code>gfortran</code> module is loaded.</p>
</li>
</ul>
<p>For <code>makefiles</code>,</p>
<ul>
<li>GNU Make tutorial: <a href="http://opensourceforu.com/2012/06/gnu-make-in-detail-for-beginners/">http://opensourceforu.com/2012/06/gnu-make-in-detail-for-beginners/</a></li>
<li>GNU Make manual: <a href="https://www.gnu.org/s/make/manual/make.html">https://www.gnu.org/s/make/manual/make.html</a></li>
<li>If you have a lot of time on your hands, a book: <a href="https://notendur.hi.is/jonasson/software/make-book/">https://notendur.hi.is/jonasson/software/make-book/</a></li>
</ul>
<p>The NEMS build system uses the GNU Make Standard Library, documented here:</p>
<ul>
<li><a href="https://gmsl.sourceforge.io/">https://gmsl.sourceforge.io/</a></li>
</ul>
<h2>The NEMSAppBuilder </h2>
<p>This was the main build system prior to the introduction of the pure Make system. There is still a script by that name, to ensure backward-compatibility for apps that use the NEMSAppBuilder. However, it no longer has graphical build capabilities. For those that require a graphical build system, we suggest using an Integrated Development Environment, such as Eclipse.</p>
<p>The syntax for running the NEMSAppBuilder is: </p>
<pre class="fragment">./NEMS/NEMSAppBuilder (options) app=(build-target)
</pre><p>Here, the <code>(build-target)</code> is the application build target, also known as the "build," or "project." It corresponds to a <code>(build-target).appBuild</code> file at the top-level (app) checkout directory.</p>
<p>The <code>(options)</code> should be one of the following:</p>
<ul>
<li><code>rebuild</code> &mdash; clean the source directory before recompiling.</li>
<li><code>norebuild</code> &mdash; do not clean; reuse existing libraries and object files whenever possible.</li>
</ul>
<p>Using the new Make-based build system directly, a <code>rebuild</code> is equivalent to: </p>
<pre class="fragment">cd `NEMS`
make app=(build-target) distclean
make app=(build-target) build
</pre><p>while a <code>norebuild</code> is equivalent to: </p>
<pre class="fragment">cd `NEMS`
make app=(build-target) build
</pre><p>Contrary to prior versions of the NEMSAppBuilder, the script will not enable a parallel build automatically. To do a parallel build, one must use the <code>-j</code> option to <code>make</code>.</p>
<h2>Troubleshooting Failed Builds </h2>
<h3>Incomplete Checkout</h3>
<p>When there are network problems or high server load, your clone of the git repository may fail. Unfortunately, with Git, there is no way to resume a failed clone. You must start over with a new clone.</p>
<h3>Unclean Environment</h3>
<p>Setting up your environment incorrectly can lead to problems while building. If you see build issues from a clean, new checkout, this may be the problem. You should remove all <code>module</code> commands from your <code>~/.*rc</code> files and get a clean, new login shell. Then retry the build.</p>
<h3>Unclean Checkout</h3>
<p>Another common cause of failed builds is having unintended changes in your source code or build system, or a corrupted repository checkout or clone. To test for this, get a clean, new clone of the repository and retry.</p>
<h3>Unsupported Platform</h3>
<p>Some apps only support a few platforms. For example, the NEMSGSM app is only supported on WCOSS Phase 1 (Gyre/Tide) and NOAA Theia. Attempts to build on other platforms may or may not work. Sometimes the app will try, and fail, to build; other times it will not even make the attempt.</p>
<h3>Simultaneous Builds</h3>
<p>Attempting to build multiple times in the same NEMS checkout directory will cause unexpected failures. For example, if you are running the regression test system twice at once, multiple builds will happen at the same time. On Theia, this frequently shows up as a massive, many terabyte, file which cannot be created due to fileset quota limits. Other failure modes are possible. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
